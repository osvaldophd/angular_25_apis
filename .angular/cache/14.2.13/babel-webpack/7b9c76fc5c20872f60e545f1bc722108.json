{"ast":null,"code":"import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n  constructor(destination) {\n    super();\n    this.isStopped = false;\n\n    if (destination) {\n      this.destination = destination;\n\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  static create(next, error, complete) {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  next(value) {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value);\n    }\n  }\n\n  error(err) {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n\n      this._error(err);\n    }\n  }\n\n  complete() {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n\n      this._complete();\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null;\n    }\n  }\n\n  _next(value) {\n    this.destination.next(value);\n  }\n\n  _error(err) {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  _complete() {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n}\nconst _bind = Function.prototype.bind;\n\nfunction bind(fn, thisArg) {\n  return _bind.call(fn, thisArg);\n}\n\nclass ConsumerObserver {\n  constructor(partialObserver) {\n    this.partialObserver = partialObserver;\n  }\n\n  next(value) {\n    const {\n      partialObserver\n    } = this;\n\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err) {\n    const {\n      partialObserver\n    } = this;\n\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete() {\n    const {\n      partialObserver\n    } = this;\n\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n}\n\nexport class SafeSubscriber extends Subscriber {\n  constructor(observerOrNext, error, complete) {\n    super();\n    let partialObserver;\n\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      partialObserver = {\n        next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,\n        error: error !== null && error !== void 0 ? error : undefined,\n        complete: complete !== null && complete !== void 0 ? complete : undefined\n      };\n    } else {\n      let context;\n\n      if (this && config.useDeprecatedNextContext) {\n        context = Object.create(observerOrNext);\n\n        context.unsubscribe = () => this.unsubscribe();\n\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context)\n        };\n      } else {\n        partialObserver = observerOrNext;\n      }\n    }\n\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n\n}\n\nfunction handleUnhandledError(error) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    reportUnhandledError(error);\n  }\n}\n\nfunction defaultErrorHandler(err) {\n  throw err;\n}\n\nfunction handleStoppedNotification(notification, subscriber) {\n  const {\n    onStoppedNotification\n  } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\nexport const EMPTY_OBSERVER = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop\n};","map":{"version":3,"sources":["/Volumes/arquivo-osvaldo/WWW/treinamento/angular_25_apis/node_modules/rxjs/dist/esm/internal/Subscriber.js"],"names":["isFunction","isSubscription","Subscription","config","reportUnhandledError","noop","nextNotification","errorNotification","COMPLETE_NOTIFICATION","timeoutProvider","captureError","Subscriber","constructor","destination","isStopped","add","EMPTY_OBSERVER","create","next","error","complete","SafeSubscriber","value","handleStoppedNotification","_next","err","_error","_complete","unsubscribe","closed","_bind","Function","prototype","bind","fn","thisArg","call","ConsumerObserver","partialObserver","handleUnhandledError","observerOrNext","undefined","context","useDeprecatedNextContext","Object","useDeprecatedSynchronousErrorHandling","defaultErrorHandler","notification","subscriber","onStoppedNotification","setTimeout"],"mappings":"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","sourcesContent":["import { isFunction } from './util/isFunction';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\nexport class Subscriber extends Subscription {\n    constructor(destination) {\n        super();\n        this.isStopped = false;\n        if (destination) {\n            this.destination = destination;\n            if (isSubscription(destination)) {\n                destination.add(this);\n            }\n        }\n        else {\n            this.destination = EMPTY_OBSERVER;\n        }\n    }\n    static create(next, error, complete) {\n        return new SafeSubscriber(next, error, complete);\n    }\n    next(value) {\n        if (this.isStopped) {\n            handleStoppedNotification(nextNotification(value), this);\n        }\n        else {\n            this._next(value);\n        }\n    }\n    error(err) {\n        if (this.isStopped) {\n            handleStoppedNotification(errorNotification(err), this);\n        }\n        else {\n            this.isStopped = true;\n            this._error(err);\n        }\n    }\n    complete() {\n        if (this.isStopped) {\n            handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n        }\n        else {\n            this.isStopped = true;\n            this._complete();\n        }\n    }\n    unsubscribe() {\n        if (!this.closed) {\n            this.isStopped = true;\n            super.unsubscribe();\n            this.destination = null;\n        }\n    }\n    _next(value) {\n        this.destination.next(value);\n    }\n    _error(err) {\n        try {\n            this.destination.error(err);\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n    _complete() {\n        try {\n            this.destination.complete();\n        }\n        finally {\n            this.unsubscribe();\n        }\n    }\n}\nconst _bind = Function.prototype.bind;\nfunction bind(fn, thisArg) {\n    return _bind.call(fn, thisArg);\n}\nclass ConsumerObserver {\n    constructor(partialObserver) {\n        this.partialObserver = partialObserver;\n    }\n    next(value) {\n        const { partialObserver } = this;\n        if (partialObserver.next) {\n            try {\n                partialObserver.next(value);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n    error(err) {\n        const { partialObserver } = this;\n        if (partialObserver.error) {\n            try {\n                partialObserver.error(err);\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n        else {\n            handleUnhandledError(err);\n        }\n    }\n    complete() {\n        const { partialObserver } = this;\n        if (partialObserver.complete) {\n            try {\n                partialObserver.complete();\n            }\n            catch (error) {\n                handleUnhandledError(error);\n            }\n        }\n    }\n}\nexport class SafeSubscriber extends Subscriber {\n    constructor(observerOrNext, error, complete) {\n        super();\n        let partialObserver;\n        if (isFunction(observerOrNext) || !observerOrNext) {\n            partialObserver = {\n                next: observerOrNext !== null && observerOrNext !== void 0 ? observerOrNext : undefined,\n                error: error !== null && error !== void 0 ? error : undefined,\n                complete: complete !== null && complete !== void 0 ? complete : undefined,\n            };\n        }\n        else {\n            let context;\n            if (this && config.useDeprecatedNextContext) {\n                context = Object.create(observerOrNext);\n                context.unsubscribe = () => this.unsubscribe();\n                partialObserver = {\n                    next: observerOrNext.next && bind(observerOrNext.next, context),\n                    error: observerOrNext.error && bind(observerOrNext.error, context),\n                    complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n                };\n            }\n            else {\n                partialObserver = observerOrNext;\n            }\n        }\n        this.destination = new ConsumerObserver(partialObserver);\n    }\n}\nfunction handleUnhandledError(error) {\n    if (config.useDeprecatedSynchronousErrorHandling) {\n        captureError(error);\n    }\n    else {\n        reportUnhandledError(error);\n    }\n}\nfunction defaultErrorHandler(err) {\n    throw err;\n}\nfunction handleStoppedNotification(notification, subscriber) {\n    const { onStoppedNotification } = config;\n    onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\nexport const EMPTY_OBSERVER = {\n    closed: true,\n    next: noop,\n    error: defaultErrorHandler,\n    complete: noop,\n};\n"]},"metadata":{},"sourceType":"module"}